= = = = = = = = = = = = = = = =

2024/5/20:
morning
Try to do this in some other way using recursive thinking generate(str: string, current: float, numbers: list)
This one is done recursively by "as", although there are parentheses but there are (incomplete parentheses, repeated problems)

PM
Try to find a problem when you find that the two problems are not recursively solved, use Liam J's enumeration algorithm. I used it on this day
itertools.permutations(test_numbers, 4) and itertools.product(['*', '/', '+', '-'], repeat = 3)
To generate a reasonable expression. But I still don't know what to do about the parentheses.

evening
Because I can't think of a suitable algorithm to generate this bracket, but after looking at a csdn website, I found that the composition of brackets is very small
I suddenly feel as if the style of enumeration parentheses with the program is not useful directly, enumeration there is a list on the line (only 11 cases), and successful
The output of the parenthesized expression is complete but there are still some parentheses that are not removed and the commutative and associative laws are not solved

= = = = = = = = = = = = = = = =

2024/5/21:

morning
Want to write a method to determine whether two equations are equivalent (you can drill through the commutative law and associative law)
The first time I wanted to start with their style, but I found that there would be too many to enumerate and gave up the idea;
And then I wanted to write an algorithm that would turn expressions into something like Godel's numbers where every kind of equation corresponds to every value, but I couldn't figure it out for a long time
Feels completely unworkable (don't know how to construct this algorithm)

PM
Continuing to think of Godel's number, then a crazy idea improved upon him. What I was thinking was to do a compression to blur the expression
But then I extended it and I found that I could make equivalent expressions refer to the same expression and I could write my judgment function. Later this idea
To modify the standard language, I propose a concept to make all expressions as standard as possible. And pointed out the general route
1. Remove unnecessary parentheses 2. Standardize 3. Remove the function that determines whether it is equivalent to convert to a hash table and remove a similar expression

evening
The first step is carried out: classification discussion is carried out according to the type of style. For each style discussion, in which case can the bracket be removed
Liver is over

= = = = = = = = = = = = = = = =

2024/5/22:

Morning:
Finding examples where manual error finding was slow and not very accurate, I wrote another program, test.py, to verify the value and primitive of the parenthesized expression
The value of the expression is not equal, if it is not equal, the output error case (using the more special prime number as the case)

Afternoon:
So how do we do this normalization process, first of all I've defined some types of expressions that are standard, that all parenthesized expressions must satisfy
The standard format is then drawn to a conclusion that can be divided into two steps
1. Adjust the position of the + - * / symbol in the expression with the commutative law
2. Sort the same operation law such as 2 + 1 + 3 into 1 + 2 + 3

Night:
Go to step 1 of the afternoon step and add new functions to test.py to test correctness. I also find that my enumerations tend to miss things
Develop new.py files to help me enumerate and output the rest of the unconsidered cases. To observe and improve, some cases can be combined

= = = = = = = = = = = = = = = =

2024/5/23

Morning:
Do the second part yesterday afternoon and also add functions to test.py to test correctness. The.py file enumerates new situations for me

Afternoon:
Finished the second part of yesterday afternoon (nothing to say, liver is over)

Night:
A bug was detected and improved, packaged as an.exe file

= = = = = = = = = = = = = = = =